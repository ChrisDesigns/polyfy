<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<style>
		* {margin: 0; padding: 0;}
		body {background: black;}
		canvas {
			display: inline-block;
			width: 400px;
			height: 300px;
		}
	</style>
</head>
<body>
<canvas id="can" width="400" height="300"></canvas>
<video id="video" width="400" height="300" preload autoplay loop muted></video>
<script>
  var module = {};
</script>
</body>
<script src="https://unpkg.com/delaunator@3.0.2/delaunator.min.js"></script>
<script src="https://rawgit.com/phoboslab/WebGLImageFilter/master/webgl-image-filter.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/tracking-min.js"></script>
<script type="text/javascript">
	var filter = new WebGLImageFilter();
	var video = document.getElementById('video');
	var canvas = document.getElementById('can');
	var delaunay;
	var points = [];
	
	
	var ctx = canvas.getContext('2d');
	var imageData = ctx.getImageData(0, 0, video.width, video.height);
	video.addEventListener('loadedmetadata', function() {
	  canvas.width = video.videoWidth;
	  canvas.height = video.videoHeight;
	});

	video.addEventListener('play', function() {
	  var $this = this; //cache
	  (function loop() {
		if (!$this.paused && !$this.ended) {
		  ctx.drawImage($this, 0, 0);
		  imageData = ctx.getImageData(0, 0, video.width, video.height);
		  setTimeout(loop, 1000 / 30); // drawing at 30fps
		}
	  })();
	}, 0);
		
	// URL to img base64 can be used to dl canvas img
	var dataURL = canvas.toDataURL();

	function addBounds() {
		points.push([0, 0]); // left top
		points.push([0, video.height / 2]); // left mid
		points.push([0, video.height]); // left bottom
		points.push([video.width, 0]); // right top
		points.push([video.width, video.height / 2]); // right mid
		points.push([video.width, video.height]); // right bottom
		points.push([video.width / 2, 0]); // top center
		points.push([video.width / 2, video.height]); // bottom center

	}
	
	function draw() {
		delaunay = Delaunator.from(points); // new Delaunator(points) doesn't like objects
		var triangles = delaunay.triangles;
		var coordinates = [];
		
		for (var i = 0; i < triangles.length; i += 3) {
			coordinates.push([
				points[triangles[i]],
				points[triangles[i + 1]],
				points[triangles[i + 2]]
			]);
		}
		drawColors(coordinates);
	}

	function getColorAtPoint(p) {
		var x = p[0] >> 0; // bitshift is faster than floor
		var y = p[1] >> 0;
		var i = y * video.width * 4 + x * 4;
		return "rgb("+ imageData.data[i] +"," + imageData.data[i + 1] + ","+ imageData.data[i + 2] +")";
	}

	function drawColors(coordinates) {
		coordinates.forEach(function(coords) {
			ctx.beginPath();
			var coordinate = coords;
			var p0 = coordinate[0];
			var p1 = coordinate[1];
			var p2 = coordinate[2];
			ctx.moveTo(p0[0], p0[1]);
			ctx.lineTo(p1[0], p1[1]);
			ctx.lineTo(p2[0], p2[1]);
			ctx.closePath();

			var centerPoint = centroid(p0, p1, p2);
			ctx.fillStyle = getColorAtPoint(centerPoint);
			ctx.fill();
		});
	}
	function centroid(p1, p2, p3) {
		var cx = (p1[0] + p2[0] + p3[0]) / 3;
		var cy = (p1[1] + p2[1] + p3[1]) / 3;
		return [cx, cy];
	}
	
	var FastTracker = function() {
		FastTracker.base(this, 'constructor');
	};
    tracking.inherits(FastTracker, tracking.Tracker);
    tracking.Fast.THRESHOLD = 10;
    FastTracker.prototype.threshold = tracking.Fast.THRESHOLD;
	FastTracker.prototype.track = function(pixels, width, height) {
		var gray = tracking.Image.grayscale(pixels, width, height);
		var corners = tracking.Fast.findCorners(gray, width, height);
		this.emit('track', {
			data: corners
		});
	};
	
    var tracker = new FastTracker();
	tracker.on('track', function(event) {
		points = [];
		var corners = event.data;
		for (var i = 0; i < corners.length; i += 2) {
			points.push([corners[i], corners[i + 1]]);
		}
		addBounds();
		draw();
	});
	tracking.track('#video', tracker, { camera: true });
	
	
</script>
</html> 
